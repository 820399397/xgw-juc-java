1.能不能谈谈你对线程安全的理解？
线程安全是指某个函数在并发环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。
简单来说，就是多个线程同时访问共享变量的时候，得到的结果和我们预期的一样，就是线程安全。所以有四个关键词：并发、多线程、共享变量、正确完成。这里所谓的正确完成，其实就是要满足所谓的原子性、有序性和可见性。

2.共享变量
所谓共享变量，指的是多个线程都可以操作的变量。
前面我们提到过，进程是分配资源的基本单位，线程是执行的基本单位。所以，多个线程之间是可以共享一部分进程中的数据的。
在JVM中，Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可以操作保存在堆或者方法区中的同一个数据。那么，换句话说，保存在堆和方法区中的变量就是Java中的共享变量。

3.那么，Java中哪些变量是存放在堆中，哪些变量是存放在方法区中，又有哪些变量是存放在栈中的呢？
Java中共有三种变量，分别是类变量、实例变量和局部变量。他们分别存放在JVM的方法区、堆内存和栈内存中。
类变量：类变量是使用static关键字修饰的变量。类变量在内存中只有一个副本，被所有实例共享。类变量存储在方法区中。
实例变量：实例变量是使用非static关键字修饰的变量。实例变量存储在堆内存中，每个实例都有自己的一份实例变量副本。
局部变量：局部变量是在方法、构造方法或者语句块中定义的变量。局部变量存储在栈内存中，生命周期随着方法的调用结束而结束。
如果没有写操作，或者对象没有被复用，那么也不会存在线程安全问题。
对象没有被复用，意味着在不同线程中使用的对象实例是独立的，没有共享同一个实例。


4.synchronized是怎么实现的？
synchronized 是 Java 中的一个很重要的关键字，主要用来加锁。synchronized 的使用方法比较简单，主要可以用来修饰方法和代码块。根据其锁定的对象不同，可以用来定义同步方法和同步代码块。
方法级的同步是隐式的（同步方法）。同步方法的常量池中会有一个 ACC_SYNCHRONIZED 标志。当某个线程要访问某个方法的时候，会检查是否有 ACC_SYNCHRONIZED，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。
值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。

同步代码块使用 monitorenter 和 monitorexit 两个指令实现。 可以把执行 monitorenter 指令理解为加锁，执行 monitorexit 理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。
未被锁定的对象的该计数器为 0，当一个线程获得锁（执行 monitorenter ）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。
当同一个线程释放锁（执行 monitorexit 指令）的时候，计数器再自减。当计数器为 0 的时候。锁将被释放，其他线程便可以获得锁。

@See https://www.yuque.com/hollis666/hgtuok/gxq5p0 可以查看hollis老师的这篇文章

5.synchronized的锁升级过程是怎样的？
在JDK 1.6及之前的版本中，synchronized锁是通过对象内部的一个叫做监视器锁（也称对象锁）来实现的。
当一个线程请求对象锁时，如果该对象没有被锁住，线程就会获取锁并继续执行。
如果该对象已经被锁住，线程就会进入阻塞状态，直到锁被释放。
这种锁的实现方式称为“重量级锁”，因为获取锁和释放锁都需要在操作系统层面上进行线程的阻塞和唤醒，而这些操作会带来很大的开销。
在JDK 1.6之后，synchronized锁的实现发生了一些变化，引入了“偏向锁”、“轻量级锁”和“重量级锁”三种不同的状态，用来适应不同场景下的锁竞争情况。
**在JDK 15 中，废弃了偏向锁**。
所以，在Java中，锁的状态分为四种，分别是无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。
在Java中，mark word的低两位用于表示锁的状态，分别为“01”（无锁状态）、“01”（偏向锁状态）、“00”（轻量级锁状态）和“10”（重量级锁状态）。
但是由于无锁状态和偏向锁都是"01"，所以在低三位引入偏向锁标记位，用"0"表示无锁，"1"表示偏向。
可以去看32位虚拟机对象头的组成部分和64位虚拟机对象头的组成部分。@See cn.xuguowen.juc.synchronized_principle.img
具体的锁升级过程如下，这里为了方便理解，暂时不包含自旋相关的内容，锁升级过程中的自旋参考：@See

无锁：当一个线程第一次访问一个对象的同步块时，JVM会在对象头中设置该线程的Thread ID，并将对象头的状态位设置为“偏向锁”。这个过程称为“偏向”，表示对象当前偏向于第一个访问它的线程。默认情况下，偏向锁是开启的
偏向锁（Biased Locking）：当一个synchronized块被线程首次进入时，锁对象会进入偏向模式。
                    在偏向锁模式下，锁会偏向于第一个获取它的线程，JVM 会在对象头中记录该线程的 ID 作为偏向锁的持有者，并将对象头中的 Mark Word 中的一部分作为偏向锁标识。
                    在这种情况下，如果其他线程访问该对象，会先检查该对象的偏向锁标识，如果和自己的线程 ID 相同，则直接获取锁。如果不同，则该对象的锁状态就会升级到轻量级锁状态。
                    触发条件：首次进入synchronized块时自动开启，假设JVM启动参数没有禁用偏向锁。但是需要注意，在JDK 15中，偏向锁已被废除：@See
轻量级锁（Lightweight Locking）:当有另一个线程尝试获取已被偏向的锁时，偏向锁会被撤销，锁会升级为轻量级锁。
                          在轻量级锁状态中，JVM 为对象头中的 Mark Word 预留了一部分空间，用于存储指向线程栈中锁记录的指针。
                          当一个线程尝试获取轻量级锁时，JVM的做法是：
                          将对象头中的Mark Word复制到线程栈中的锁记录（Lock Record）：每个Java对象头部都有一个Mark Word，它用于存储对象自身的运行时数据，如哈希码、锁状态信息、代年龄等。
                          当线程尝试获取轻量级锁时，JVM会在当前线程的栈帧中创建一个锁记录空间，然后将对象头中的Mark Word复制到这个锁记录中。这个复制的Mark Word被称为“Displaced Mark Word”。
                          尝试通过CAS操作更新对象头的Mark Word：接下来，JVM尝试使用CAS（Compare-And-Swap）操作，将对象头的Mark Word更新为指向锁记录的指针。如果这个更新操作成功，那么这个线程就成功获取了这个对象的轻量级锁。
                          如果替换成功，则该线程获取锁成功；如果失败，则表示已经有其他线程获取了锁，则该锁状态就会升级到重量级锁状态。
                          触发条件：当有另一个线程尝试获取已被偏向的锁时，偏向锁会升级为轻量级锁。
重量级锁（Heavyweight Locking）:当轻量级锁的CAS操作失败，即出现了实际的竞争，锁会进一步升级为重量级锁。
                              当锁状态升级到重量级锁状态时，JVM 会将该对象的锁变成一个重量级锁，并在对象头中记录指向等待队列的指针。
                              此时，如果一个线程想要获取该对象的锁，则需要先进入等待队列，等待该锁被释放。当锁被释放时，JVM 会从等待队列中选择一个线程唤醒，并将该线程的状态设置为“就绪”状态，然后等待该线程重新获取该对象的锁。
                              触发条件：当轻量级锁的CAS操作失败，轻量级锁升级为重量级锁。

在轻量级锁的场景下，为什么需要将对象头中的Mark Word复制到线程栈中？
在做CAS之前，需要将对象头中的Mark Word复制到线程栈中的锁记录（Lock Record），之所以这么做的主要原因原因是为了保留对象的原始信息，复制Mark Word到线程栈中是为了在锁释放时能够恢复对象头的原始状态。
因为锁的获取与释放是成对出现的，所以在释放锁时，JVM需要使用这份复制的原始Mark Word来恢复对象头，确保对象状态的正确性。


6.synchronized 能降级么？
我们知道，synchronized 是有锁升级的过程的，会从偏向锁升级到轻量级锁和重量级锁，那么synchronized的锁有降级的过程吗？（这个问题，网上也有很多文章，五花八门。。。）
大家理解的锁降级，如果是指锁从重量级状态回退到轻量级或偏向锁状态的过程，那么可以明确的说，当前的HotSpot虚拟机实现是不支持的。
因为锁一旦升级为重量级锁，它将保持在这个状态，直到锁被完全释放。
但是，你要说，一旦一个锁从偏向、到轻量级锁、再到重量级锁加锁之后，后面的所有加锁都是以重量级锁的方式加锁了，这么说也不对！
因为有一种特殊情况的"降级"，那就是重量级锁的Monitor对象在不再被任何线程持有时，被清理和回收的过程。
这一过程确实可以在Stop-the-World（STW）暂停期间进行，这时所有Java线程都停在安全点（SafePoint）。这个过程会做一下事情：
    - 锁状态检查：在STW停顿期间，JVM会检查所有的Monitor对象。
    - 确定降级对象：JVM识别出那些没有被任何线程持有的Monitor对象。这通常是通过检查Monitor对象的锁计数器或者所有权信息来实现的。
    - "降级"操作：对于那些确定未被使用的Monitor对象，JVM会进行所谓的“deflation”操作，即清理这些对象的状态，使其不再占用系统资源。在某些情况下，这可能涉及到重置Monitor状态，释放与其相关的系统资源等。
以上，说的是 HotSpot，并不是所有虚拟机都这样，有的虚拟机还真支持从重量级锁降级到轻量级锁，比如 JRocket 这个虚拟机。
@See https://docs.oracle.com/cd/E13188_01/jrockit/docs142/usingJRA/applocks.html
When the last contending thread releases a fat lock, the lock normally remains fat. Taking a fat lock, even without contention, is more expensive than taking a fat lock (but less expensive than converting a thin lock to a fat lock). If JRockit believes that the lock would benefit from being thin (basically, if the contention was pure "bad luck" and the lock normally is uncontended), it might "deflate" it to a thin lock again.
翻译一下就是:当最后一个争用线程释放重量级锁时，锁通常仍然保持为重量级。即使没有争用，获取重量级锁的代价也比获取轻量级锁（thin lock）更高。如果JRockit认为锁会从变轻中受益，它可能会再次将其“压缩”为轻量级锁。



